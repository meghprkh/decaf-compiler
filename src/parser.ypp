%{
#include <stdio.h>
#include "ast/classes.hpp"

extern FILE *yyin;
extern int yylex (void);
void yyerror (const char *s);
int lineno = 0;

class Base* start;
extern union Node yylval;

%}

%token BOOLEAN BREAK CALLOUT CLASS CONTINUE ELSE FOR IF INT RETURN VOID
%token ID
%token <token> STRING_LITERAL INT_LITERAL CHAR_LITERAL BOOL_LITERAL
%token ASSIGN_EQ ASSIGN_PE ASSIGN_ME

%left OR
%left AND
%left EQ NE
%left LT LE GE GT
%left '+' '-'
%left '*' '/' '%'
%nonassoc '!'

%type <b> program
%type <b> expr
%type <b> literal

%%

program: expr  { $$ = $1; start = $$; }

expr
	: location
	| method_call
	| literal           { $$ = $1; }
	| expr '+' expr     { $$ = new BinExpr($1, OpType::add, $3); }
	| '-' expr
	| '!' expr
	| '(' expr ')'
	;

location
	: ID
	| ID '[' expr ']'
	;

method_call
	: method_name '(' method_args ')'
	| CALLOUT '(' STRING_LITERAL ')'
	| CALLOUT '(' STRING_LITERAL ',' callout_args ')'
	;

method_name: ID;

method_args
	: expr ',' method_args
	| expr
	| %empty
	;

callout_args
	: STRING_LITERAL ',' callout_args
	| expr ',' callout_args
	| STRING_LITERAL
	| expr
	;

literal
	: INT_LITERAL      { $$ = new IntLiteral($1); }
	| CHAR_LITERAL
	| BOOL_LITERAL
	;

bin_op
	: arith_op
	| rel_op
	| eq_op
	| cond_op
	;

arith_op: '+' | '-' | '*' | '/' | '%';
rel_op: LT | GT | LE | GE;
eq_op: EQ | NE;
cond_op: AND | OR;

%%

extern int yydebug;
int main(int argc, char **argv)
{
	if (argc == 1 ) {
		fprintf(stderr, "Correct usage: decaf filename\n");
		exit(1);
	}
	if (argc > 2) {
		fprintf(stderr, "Passing more arguments than necessary.\n");
		fprintf(stderr, "Correct usage: decaf filename\n");
	}

	yyin = fopen(argv[1], "r");
	yyparse();

	start->print();
}

void yyerror(const char *s)
{
	fprintf(stderr, "error: %s at line %d\n", s, lineno);
}
